<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Lambda//Void α v0.1</title>
<style>
  body {
    margin: 0;
    font-family: 'Courier New', Courier, monospace;
    background: #12131a;
    color: #00ffe7;
    display: flex;
    height: 100vh;
    overflow: hidden;
    user-select: none;
  }
  #sidebar {
    width: 300px;
    background: #0f1015;
    border-right: 2px solid #00ffe7;
    display: flex;
    flex-direction: column;
    padding: 20px;
    box-sizing: border-box;
  }
  #main {
    flex-grow: 1;
    padding: 20px;
    box-sizing: border-box;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: linear-gradient(45deg, #0a0b11, #1c1d26);
  }
  h1 {
    margin: 0 0 20px 0;
    font-size: 2.5em;
    text-shadow: 0 0 10px #00ffe7;
  }
  button {
    background: #12131a;
    border: 2px solid #00ffe7;
    color: #00ffe7;
    font-size: 1.1em;
    padding: 10px 15px;
    margin: 8px 0;
    cursor: pointer;
    transition: background 0.3s, color 0.3s;
    width: 100%;
    box-sizing: border-box;
  }
  button:hover:not(:disabled) {
    background: #00ffe7;
    color: #12131a;
  }
  button:disabled {
    opacity: 0.3;
    cursor: not-allowed;
  }
  #tokensDisplay, #upgradesDisplay, #achievementsPanel {
    margin-bottom: 15px;
    font-size: 1.1em;
  }
  #logArea {
    background: #111122;
    border: 1px solid #00ffe7;
    padding: 10px;
    height: 150px;
    overflow-y: auto;
    font-size: 0.9em;
    line-height: 1.3em;
    margin-bottom: 15px;
    border-radius: 4px;
    font-family: monospace;
  }
  #expressionVisualizer {
    background: #0f0f1a;
    border: 1px solid #00ffe7;
    border-radius: 4px;
    width: 100%;
    max-width: 600px;
    height: 300px;
    display: block;
    margin-bottom: 15px;
  }
  #controls {
    margin-bottom: 15px;
    width: 100%;
  }
  #controls button {
    width: auto;
    margin-right: 10px;
    min-width: 180px;
  }
  .achievement {
    margin: 2px 0;
  }
  .achievement.unlocked {
    color: #0f0;
  }
  .glitch {
    color: #00ffe7;
    text-shadow:
      1px 0 red,
      -1px 0 cyan,
      2px 0 magenta;
    animation: glitch 1.5s infinite;
  }
  @keyframes glitch {
    0% { text-shadow: 1px 0 red, -1px 0 cyan, 2px 0 magenta; }
    20% { text-shadow: -2px 0 red, 2px 0 cyan, -1px 0 magenta; }
    40% { text-shadow: 2px 0 red, -2px 0 cyan, 1px 0 magenta; }
    60% { text-shadow: -1px 0 red, 1px 0 cyan, -2px 0 magenta; }
    80% { text-shadow: 1px 0 red, -1px 0 cyan, 2px 0 magenta; }
    100% { text-shadow: -2px 0 red, 2px 0 cyan, -1px 0 magenta; }
  }
</style>
</head>
<body>

<div id="sidebar">
  <h1 class="glitch">Lambda<span style="color:#ff00c8">//</span>Void α v0.1</h1>
  <div id="tokensDisplay">Tokens: 0</div>

  <div id="upgradesDisplay">
    <button id="buyReduction">Upgrade Reduction (Cost: 20 tokens)</button>
    <button id="buyComplexity">Upgrade Complexity (Cost: 25 tokens)</button>
    <button id="buySynthesizer">Upgrade Synthesizer (Cost: 30 tokens)</button>
  </div>

  <div id="controls">
    <button id="generateBtn">Generate Lambda Expression (Cost: 10 tokens)</button>
    <button id="generateRecBtn">Generate Recursive Expr (Y Combinator) (Cost: 15 tokens)</button>
    <button id="reduceBtn">Reduce Expression</button>
  </div>

  <div id="achievementsPanel">
    <strong>Achievements:</strong>
    <div id="achievementsList"></div>
  </div>

  <div id="logArea"></div>
</div>

<div id="main">
  <canvas id="expressionVisualizer" width="600" height="300"></canvas>
</div>

<audio id="bgMusic" loop autoplay volume="0.15">
  <source src="https://files.catbox.moe/z1r6ez.mp3" type="audio/mpeg" />
</audio>

<script>
  // === Game State ===
  const state = {
    tokens: 50,
    expression: null,
    computeCycles: 0,
    upgrades: {
      reduction: 1,
      complexity: 1,
      synthesizer: 1,
    },
    achievements: {},
  };

  // === Y Combinator Expression ===
  const YCombinator = {
    type: 'abs',
    param: 'f',
    body: {
      type: 'app',
      func: {
        type: 'abs',
        param: 'x',
        body: {
          type: 'app',
          func: { type: 'var', name: 'f' },
          arg: {
            type: 'app',
            func: { type: 'var', name: 'x' },
            arg: { type: 'var', name: 'x' }
          }
        }
      },
      arg: {
        type: 'abs',
        param: 'x',
        body: {
          type: 'app',
          func: { type: 'var', name: 'f' },
          arg: {
            type: 'app',
            func: { type: 'var', name: 'x' },
            arg: { type: 'var', name: 'x' }
          }
        }
      }
    }
  };

  // === Helper: Deep clone an expression ===
  function deepClone(obj) {
    return JSON.parse(JSON.stringify(obj));
  }

  // === Expression to String Conversion ===
  function exprToString(expr) {
    if (!expr) return '';
    switch (expr.type) {
      case 'var': return expr.name;
      case 'abs': return `λ${expr.param}.${exprToString(expr.body)}`;
      case 'app':
        // If expr equals YCombinator, display 'Y'
        if (JSON.stringify(expr) === JSON.stringify(YCombinator)) return 'Y';
        return `(${exprToString(expr.func)} ${exprToString(expr.arg)})`;
    }
  }

  // === Generate random variable name ===
  function randomVarName() {
    const chars = 'xyzuvw';
    return chars[Math.floor(Math.random() * chars.length)];
  }

  // === Generate random lambda expression ===
  function generateRandomExpr(complexity = 1) {
    if (complexity >= 5 && Math.random() < 0.1) {
      // 10% chance to generate Y combinator at complexity >= 5
      return deepClone(YCombinator);
    }
    const choice = Math.random();
    if (complexity <= 1) {
      return { type: 'var', name: randomVarName() };
    }
    if (choice < 0.4) {
      return {
        type: 'abs',
        param: randomVarName(),
        body: generateRandomExpr(complexity - 1)
      };
    } else {
      return {
        type: 'app',
        func: generateRandomExpr(complexity - 1),
        arg: generateRandomExpr(complexity - 1)
      };
    }
  }

  // === Substitute variable in expr with replacement ===
  function substitute(expr, variable, replacement) {
    switch (expr.type) {
      case 'var':
        if (expr.name === variable) return deepClone(replacement);
        else return expr;
      case 'abs':
        if (expr.param === variable) return expr; // variable shadowed
        else return {
          type: 'abs',
          param: expr.param,
          body: substitute(expr.body, variable, replacement)
        };
      case 'app':
        return {
          type: 'app',
          func: substitute(expr.func, variable, replacement),
          arg: substitute(expr.arg, variable, replacement)
        };
    }
  }

  // === Beta Reduction ===
  function reduceOnce(expr) {
    switch (expr.type) {
      case 'app':
        if (expr.func.type === 'abs') {
          // Beta reduction
          return substitute(expr.func.body, expr.func.param, expr.arg);
        } else {
          // Try to reduce func or arg
          const reducedFunc = reduceOnce(expr.func);
          if (JSON.stringify(reducedFunc) !== JSON.stringify(expr.func)) {
            return { type: 'app', func: reducedFunc, arg: expr.arg };
          }
          const reducedArg = reduceOnce(expr.arg);
          if (JSON.stringify(reducedArg) !== JSON.stringify(expr.arg)) {
            return { type: 'app', func: expr.func, arg: reducedArg };
          }
          return expr; // no reduction possible
        }
      case 'abs':
        const reducedBody = reduceOnce(expr.body);
        if (JSON.stringify(reducedBody) !== JSON.stringify(expr.body)) {
          return { type: 'abs', param: expr.param, body: reducedBody };
        }
        return expr;
      case 'var':
        return expr;
    }
  }

  // === Check if expression contains YCombinator ===
  function containsY(expr) {
    if (!expr) return false;
    if (JSON.stringify(expr) === JSON.stringify(YCombinator)) return true;
    switch (expr.type) {
      case 'var':
        return false;
      case 'abs':
        return containsY(expr.body);
      case 'app':
        return containsY(expr.func) || containsY(expr.arg);
    }
  }

  // === Expression Visualizer ===
  const canvas = document.getElementById('expressionVisualizer');
  const ctx = canvas.getContext('2d');
  const nodeRadius = 18;
  const xSpacing = 80;
  const ySpacing = 60;

  // Calculate tree width recursively
  function calcWidth(expr) {
    if (!expr) return 0;
    switch (expr.type) {
      case 'var': return 1;
      case 'abs': return calcWidth(expr.body);
      case 'app': return calcWidth(expr.func) + calcWidth(expr.arg);
    }
  }

  // Draw expression tree with position
  function drawExpr(expr, x, y, highlightY) {
    if (!expr) return 0;
    switch (expr.type) {
      case 'var':
        ctx.fillStyle = '#00ffe7';
        ctx.strokeStyle = '#00ffe7';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#000';
        ctx.font = '18px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(expr.name, x, y);
        return 1;
      case 'abs': {
        const width = calcWidth(expr.body) * xSpacing;
        // Draw node
        ctx.fillStyle = '#ff0090';
        ctx.strokeStyle = '#ff0090';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.rect(x - nodeRadius, y - nodeRadius, nodeRadius * 2, nodeRadius * 2);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#000';
        ctx.font = '18px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('λ' + expr.param, x, y);
        // Draw body below
        const childX = x;
        const childY = y + ySpacing;
        const childWidth = drawExpr(expr.body, childX, childY, highlightY);
        // Draw line down
        ctx.strokeStyle = '#00ffe7';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y + nodeRadius);
        ctx.lineTo(childX, childY - nodeRadius);
        ctx.stroke();
        return 1;
      }
      case 'app': {
        const leftWidth = calcWidth(expr.func);
        const rightWidth = calcWidth(expr.arg);
        const totalWidth = leftWidth + rightWidth;
        // Positions for children
        const leftX = x - (rightWidth * xSpacing) / 2;
        const rightX = x + (leftWidth * xSpacing) / 2;
        // Highlight if this subtree is YCombinator
        const isY = highlightY && JSON.stringify(expr) === JSON.stringify(YCombinator);

        ctx.fillStyle = isY ? '#00ff00' : '#0099ff';
        ctx.strokeStyle = isY ? '#00ff00' : '#0099ff';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.ellipse(x, y, nodeRadius * 1.5, nodeRadius, 0, 0, 2 * Math.PI);
        ctx.fill();
        ctx.stroke();
        ctx.fillStyle = '#000';
        ctx.font = '18px monospace';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText('@', x, y);

        const childY = y + ySpacing;

        // Draw children
        drawExpr(expr.func, leftX, childY, highlightY);
        drawExpr(expr.arg, rightX, childY, highlightY);

        // Draw lines
        ctx.strokeStyle = '#00ffe7';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, y + nodeRadius);
        ctx.lineTo(leftX, childY - nodeRadius);
        ctx.moveTo(x, y + nodeRadius);
        ctx.lineTo(rightX, childY - nodeRadius);
        ctx.stroke();
        return totalWidth;
      }
    }
  }

  // === UI Elements ===
  const tokensDisplay = document.getElementById('tokensDisplay');
  const logArea = document.getElementById('logArea');
  const generateBtn = document.getElementById('generateBtn');
  const generateRecBtn = document.getElementById('generateRecBtn');
  const reduceBtn = document.getElementById('reduceBtn');
  const buyReductionBtn = document.getElementById('buyReduction');
  const buyComplexityBtn = document.getElementById('buyComplexity');
  const buySynthesizerBtn = document.getElementById('buySynthesizer');
  const achievementsList = document.getElementById('achievementsList');

  // === Log helper ===
  function log(text) {
    const now = new Date().toLocaleTimeString();
    logArea.innerText = `[${now}] ${text}\n` + logArea.innerText;
  }

  // === Update UI ===
  function updateUI() {
    tokensDisplay.textContent = `Tokens: ${state.tokens}`;
    buyReductionBtn.disabled = state.tokens < 20;
    buyComplexityBtn.disabled = state.tokens < 25;
    buySynthesizerBtn.disabled = state.tokens < 30;
    generateBtn.disabled = state.tokens < 10;
    generateRecBtn.disabled = state.tokens < 15;

    // Achievements display
    achievementsList.innerHTML = '';
    Object.entries(state.achievements).forEach(([id, ach]) => {
      const div = document.createElement('div');
      div.className = 'achievement' + (ach.unlocked ? ' unlocked' : '');
      div.textContent = `${ach.unlocked ? '✓' : '✗'} ${ach.name}`;
      achievementsList.appendChild(div);
    });
  }

  // === Achievements ===
  const ACHIEVEMENTS = {
    firstExpr: { name: 'Generate your first expression', unlocked: false },
    firstRecExpr: { name: 'Generate recursive Y combinator', unlocked: false },
    firstReduction: { name: 'Perform your first reduction', unlocked: false },
    tokenCollector: { name: 'Collect 100 tokens', unlocked: false },
  };

  function unlockAchievement(id) {
    if (!state.achievements[id]) {
      state.achievements[id] = { ...ACHIEVEMENTS[id], unlocked: true };
      log(`Achievement unlocked: ${ACHIEVEMENTS[id].name}`);
      updateUI();
    }
  }

  // === Save/Load ===
  function saveGame() {
    const saveData = {
      tokens: state.tokens,
      expression: state.expression,
      upgrades: state.upgrades,
      achievements: state.achievements,
    };
    localStorage.setItem('lambdaVoidSave', JSON.stringify(saveData));
    log('Game saved.');
  }

  function loadGame() {
    const data = localStorage.getItem('lambdaVoidSave');
    if (data) {
      try {
        const obj = JSON.parse(data);
        state.tokens = obj.tokens || 0;
        state.expression = obj.expression || null;
        state.upgrades = obj.upgrades || { reduction:1, complexity:1, synthesizer:1 };
        state.achievements = obj.achievements || {};
        log('Game loaded.');
        updateUI();
        draw();
      } catch (e) {
        log('Failed to load save data.');
      }
    } else {
      log('No save data found.');
    }
  }

  // === Game Actions ===

  // Generate random expression action
  generateBtn.onclick = () => {
    if (state.tokens < 10) {
      log('Not enough tokens to generate expression.');
      return;
    }
    state.tokens -= 10;
    const complexity = 1 + state.upgrades.complexity;
    state.expression = generateRandomExpr(complexity);
    log(`Generated expression: ${exprToString(state.expression)}`);
    unlockAchievement('firstExpr');
    updateUI();
    draw();
    saveGame();
  };

  // Generate recursive (Y combinator) expression
  generateRecBtn.onclick = () => {
    if (state.tokens < 15) {
      log('Not enough tokens to generate recursive expression.');
      return;
    }
    state.tokens -= 15;
    state.expression = deepClone(YCombinator);
    log('Generated recursive Y combinator expression.');
    unlockAchievement('firstRecExpr');
    updateUI();
    draw();
    saveGame();
  };

  // Reduce expression once
  reduceBtn.onclick = () => {
    if (!state.expression) {
      log('No expression to reduce.');
      return;
    }
    const beforeStr = JSON.stringify(state.expression);
    let reduced = state.expression;
    for (let i = 0; i < state.upgrades.reduction; i++) {
      reduced = reduceOnce(reduced);
    }
    if (JSON.stringify(reduced) === beforeStr) {
      log('Expression is in normal form; no further reduction possible.');
    } else {
      state.expression = reduced;
      state.tokens += 5 * state.upgrades.synthesizer;
      log(`Reduced expression to: ${exprToString(state.expression)} (+${5 * state.upgrades.synthesizer} tokens)`);
      unlockAchievement('firstReduction');
      if (state.tokens >= 100) unlockAchievement('tokenCollector');
      updateUI();
      draw();
      saveGame();
    }
  };

  // Buy upgrades
  buyReductionBtn.onclick = () => {
    if (state.tokens < 20) return;
    state.tokens -= 20;
    state.upgrades.reduction++;
    log(`Reduction upgrade purchased! Level: ${state.upgrades.reduction}`);
    updateUI();
    saveGame();
  };
  buyComplexityBtn.onclick = () => {
    if (state.tokens < 25) return;
    state.tokens -= 25;
    state.upgrades.complexity++;
    log(`Complexity upgrade purchased! Level: ${state.upgrades.complexity}`);
    updateUI();
    saveGame();
  };
  buySynthesizerBtn.onclick = () => {
    if (state.tokens < 30) return;
    state.tokens -= 30;
    state.upgrades.synthesizer++;
    log(`Synthesizer upgrade purchased! Level: ${state.upgrades.synthesizer}`);
    updateUI();
    saveGame();
  };

  // === Draw function ===
  function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    if (state.expression) {
      const highlightY = containsY(state.expression);
      drawExpr(state.expression, canvas.width / 2, 40, highlightY);
    } else {
      ctx.fillStyle = '#444';
      ctx.font = '20px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('No expression loaded', canvas.width / 2, canvas.height / 2);
    }
  }

  // === Initialization ===
  function init() {
    // Initialize achievements list empty
    Object.keys(ACHIEVEMENTS).forEach(k => {
      state.achievements[k] = { ...ACHIEVEMENTS[k], unlocked: false };
    });
    loadGame();
    updateUI();
    draw();
  }

  init();

  // Auto-save every 30 seconds
  setInterval(saveGame, 30000);

</script>

</body>
</html>
